---
{"dg-publish":true,"permalink":"/study/computer-network/l5-application-layer/","created":"2023-12-14T17:07:08.000+09:00","updated":"2025-01-14T15:33:44.000+09:00"}
---

network application: 일반적으로 우리가 사용하는 소프트웨어 응용  프로그램(프로세스)

유용한 애플리케이션에 대한 상상이, 인터넷 성공의 동기부여를 이룩해냈다.
그렇기 때문에 애플리케이션에서부터 Top-down으로 접근하는 것이야 말로 네트워크의 본질이다.

애플리케이션 계층에서 우리가 알아야 할것은, 여러가지 다양한 애플리케이션과 그 애플리케이션들이 사용하는 애플리케이션 프로토콜, [[L4-Transport Layer.\|트랜스포트 계층]] 인터페이스를 다루는 것이 전부이다.

# Network Application
문제는 네트워크 애플리케이션이란, 단지 오프라인으로 컴퓨터와 체스나 두는게 아니라는 것이다.
서로 다른 종단 시스템간의 통신을 통해, 플레이어 대 플레이어의  온라인 체스 서비스를 제공하는 것에 가깝다. 따라서 애플리케이션 개발자는 **양측간에 원활한 통신**이 이뤄지도록 설계해야한다.

# Network Application Architecture
양측간의 통신은 어떻게 이뤄져야 하는가?
가장 단순하게 유저 대 유저의 직접 통신을 생각할 수 있다. 만약, 체스만 둔다면 그것도 좋은 방법일 것이다. 하지만, 만약 LoL을 한다면 어떨까?
생각만 해도 머리가 아프다 ${}_5C_2$의 연결이 동시에 이뤄져야 할 것이다. 그렇다면 배틀그라운드는? ... 뿐만아니라, 타격 선후 판정은?... 문제가 복잡해진다.

## client-server architecture
다수의 클라이언트들이 동시에 연결할 수 있는 하나의 **상시 가동 서버**를 두는 구조이다.
이 구조에서 클라는 서로 **직접 통신하지 않는다.**

이제 대부분의 문제가 해결된다. 하지만, 때로는 하나의 서버가 모든 클라의 통신을 받는 것은 불가능하다. 이용자가 너무 많다면 그렇다.

### data center
그래서 다수의 서버들이 모여서 하나의 강력한 가상 서버를 생성하는 방식이 사용된다. 이러한 서버들의 집합을 데이터 센터라 한다.

클라-서버 구조는 강력하지만, 한가지 단점이 있다. 상시 운행되는 서버를 가지고 있어야 한다는 것이다. -비용 문제

## P2P architecture
대신에 각각의 유저들이 peer라는 **간헐적으로만 서로 연결**되는 호스트가되면 어떨까? 거미줄처럼 서로서로 연결되는 구조가 탄생한다. 대표적으로 torrent 애플리케이션이 이러한 구조를 사용한다. 이를 peer-to-peer라 부른다.

# Process Communicating
process : end system에서 실행되는 프로그램.

애플리케이션 계층에서의 양측간의 통신은 이 프로세스간에 message를 주고받는 것을 의미한다.
프로세스간의 통신은 물론, 하나의 시스템 내에서도 이뤄지지만, 서로 다른 시스템간의 통신이 컴퓨터 네트워크 과목에서 다뤄진다.

따라서 애플리케이션은 프로세스와 프로세스가 메시지를 주고받는데, 아래와 같이 네트워크를 경유하게 된다.
>Process1 -> Network -> Process2

이때, 소켓Socket이 Process와 Network를 잇는 인터페이스로서 사용된다.
### Socket
프로세스가 네트워크와 메시지를 주고 받는 창구로,
애플리케이션과 네트워크 사이의 API(Application Programming Interface)이다.
호스트는 여러개의 소켓을 가질 수 있다.

## Adressing Process
특정한 프로세스에 메시지를 전송하려면, 그 프로세스를 특정할 주소가 필요하다.
먼저, 프로세스를 실행하고 있는 호스트의 주소가 필요하고, 호스트를 특정한 다음에는 최종적으로 메시지가 도착할 프로세스의 주소가 필요하다.

>(1) 호스트는 IP 주소로 식별된다.
>(2) 프로세스는 Port로 식별된다.

하나의 소켓은 하나의 IP 주소와 하나의 Port 번호를 통해 인터넷 상에서 고유하게 식별된다.
문제는 하나의 소켓이 여러개의 프로세스와 연결될 수도 있다는 점이다. 따라서, 프로세스를 소켓으로만 식별한다는 것은 사실 조금 부정확하다.

# Transport Service Available to Applications

**애플리케이션의 입장에서 인터넷은 미지의 세계이다.** 이 네트워크를 통해 상대방에게 도달한 정보가 내가 의도한 정보가 아니라는 보장이 어디에 있는가? 혹은 네트워크 혼선에 의해 정보가 도달하지 못할 수도 있다. 즉, 미지의 세계로 메시지를 보내는 애플리케이션은 위험으로부터 안전할 수 있기를 원한다.
따라서, 애플리케이션은 이러한 문제들을 해결하기 위해 **Transport 계층에게 도움을 요청**한다.
그것을 Transport가 Application에 제공하는 Service라고 부른다.

### Reliable Data Transfer
정보의 신뢰성, 즉 손실과 오류가 없음을 보장한다.

### Throughput
비트 전달 속도의 하방을 보장한다. #Q 사실 이게 Timing과 무슨 차이인지 잘 모르겠다.

### Timing
비트 전달에 시간제한을 둔다.

### Security
보안의 3요소를 만족시킨다.
- confidentiality 기밀성
- integrity 무결성
- authentication 종단 인증

# Transport Service Provided by the Internet.

바로 위에서, Transport 계층이 제공하는 서비스들의 일반적인 항목들에 대해 살펴봤다.
이러한 서비스들은 애플리케이션이 어떤 서비스 집합을 지닌 프로토콜Protocol을 요청하느냐에 따라, 주어질 수도 있고 그렇지 않을 수도 있다.

## TCP

## UDP

# Application-layer Protocol.

위에서 배운 절차들을 통해 message를 주고 받는 방법을 배울 수 있었다.
그렇다면, 도달한 메시지를 어떻게 읽어들일 것인가?에 관한 내용이 애플리케이션 프로토콜이다.
85p

# Applications and Protocols.

## Web and HTTP
### Cookie, Web Cache=Proxy Server

## SMTP, PoP3, TELNET etc..

