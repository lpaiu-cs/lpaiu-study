---
{"dg-publish":true,"permalink":"/== Study/Operating System/P1 System Call 함수 정의하기/","created":"2024-11-13T21:22:22.000+09:00","updated":"2025-04-14T15:40:14.994+09:00"}
---

시스템 콜을 통해서만 커널에 접근할 수 있다.
그렇다면, 시스템 콜은 어떻게 이뤄지는 것일까?

먼저, 커널에는 시스템 콜 함수가 정의되어 있다.
[[== Study/Operating System/Project 1\|Project 1]]에서 우리는 시스템 콜 함수를 추가하고, 이를 호출하는 일을 했었다.

여기에는 크게 3가지 일이 필요하다.

(1) 커널 함수를 정의한다.
(2) 테이블에 커널 함수를 등록한다.
(3) 헤더 파일에 커널함수를 선언한다.

## 커널 함수 정의 Definition

가장 먼저, 정의하려는 시스템 콜 동작을 구현해야 한다.
이를 위해서는 커널에 내가 원하는 함수를 작성해야 한다.
따라서 다음 위치에 내가 원하는 함수들이 포함된 소스 파일을 생성했다.

.../linux-4.20.11/kernel/sslab_my_stack.c

Project 1에서는 해당 소스 파일에 스택에 push와 pop을 하는 함수를 정의했다.

## 시스템 콜 함수 등록 Registering or Mapping

정의한 커널 함수를 유저 프로그램에서 사용하기 위해서는 반드시 시스템 콜 테이블에 함수를 등록해 놓아야 한다. 유저 프로그램은 임의의 커널 함수에 접근하는 것이 불가능하기 때문이다. 유저 프로그램은 반드시 시스템 콜 식별번호를 통해서만 커널 함수에 접근할 수 있다. 이렇게 하는 이유는, 유저 프로그램이 커널함수를 미리 정해진 범위, 즉 허용된 범위에서만 접근하도록 제한하기 위함이다.

만약, 시스템 콜 테이블에 식별번호를 맵핑시켜놓지 않는다면, 앞서 정의한 커널 함수는 시스템 콜 함수로서 작동할 수 없을 것이다. *(일반적으로 시스템 콜 함수는 테이블에 정의되어 유저가 사용할 수 있는 커널 함수를 의미한다.)*

시스템 콜 테이블의 위치는 다음과 같다.

.../linux-4.20.11/arch/x86/entry/sysccalls/syscall_64.tbl

## 시스템 콜 함수 선언 Declaration

작성한 커널 함수는 소스 코드로 이루어져 있다. 소스 코드가 작동하기 위해서는 컴파일 단계를 거쳐야 한다. 이때 컴파일러는 정의된 함수의 프로토타입을 필요로 한다. 이것은 컴파일러가 각 소스 파일을 독립적으로 컴파일하기 때문이다.
각 소스 파일은 다른 소스 파일에 대한 정보가 없다. 이때 만약 다른 소스 파일에서 정의된 함수를 호출한다면, 컴파일러는 그 함수의 존재와 시그니처를 알아야 성공적으로 오브젝트 파일을 만들 수 있다. (하지만 내가 추가한 함수는 어디서도 재사용되지 않아서 사실 선언 안해도 되긴함)

이러한 함수 선언부를 헤더 파일이라 부른다. 여러모로 인터프리터 언어인 파이썬과는 다르게 작동하는 것 같다.

시스템 콜 헤더 파일의 위치는 다음과 같다.

.../linux-4.20.11/include/linux/syscalls.h

#

### Makefile

컴파일과 빌드 과정 자동화를 위한 스크립트 파일,

.../linux-4.20.11/kernel/Makefile